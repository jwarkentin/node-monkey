{"version":3,"sources":["webpack://NodeMonkey/webpack/universalModuleDefinition","webpack://NodeMonkey/webpack/bootstrap","webpack://NodeMonkey/external \"@babel/runtime/regenerator\"","webpack://NodeMonkey/./src/lib/cycle.js","webpack://NodeMonkey/external \"source-map-support\"","webpack://NodeMonkey/./src/server/index.js","webpack://NodeMonkey/./src/server/utils.js","webpack://NodeMonkey/./src/lib/common-utils.js","webpack://NodeMonkey/./src/server/bunyan-stream.js","webpack://NodeMonkey/./src/server/command-manager.js","webpack://NodeMonkey/./src/server/setup-socket.js","webpack://NodeMonkey/./src/server/ssh-manager.js","webpack://NodeMonkey/./src/server/user-manager.js","webpack://NodeMonkey/./src/server/setup-server.js"],"names":["origJSON","global","JSON","objects","paths","f","value","i","$ref","Array","nu","derez","path","Object","px","element","eval","rez","item","name","options","port","_","lastPort","instances","reg","arr","match","prep","Error","limit","trace","sourceMapSupport","stack","pobj","Promise","reject","type","inverted","obj","nameFromLevel","utils","fatal","exec","opts","a","parsed","minimist","username","write","io","writeLn","error","prompt","doneP","result","this","userManager","socketio","ns","cmdMan","socket","creds","promptId","prompts","cmdManOpts","method","args","cb","pid","cmdManager","createCmdMan","err","SSHManager","host","title","silent","Set","server","ssh2","hostKeys","fs","onClient","bind","monkey","listen","address","c","client","clients","add","onClose","SSHClient","session","stream","pty","term","ptyInfo","promptTxt","inputActive","cmdHistory","on","onAuth","onReady","val","inputOpts","msg","style","end","ctx","accept","clearScreen","inputField","abort","nextLine","setTimeout","console","newPty","master_fd","slave_fd","master","tty","slave","getWindowSize","stdin","pipe","stdout","stderr","generic","appName","onKey","_interpolate","str","varRe","vars","clear","history","autoComplete","autoCompleteMenu","input","output","UserManager","userFile","getUsers","then","usernames","userFileCache","userFileCreated","process","data","passwd","logN","r","p","toString","actualPasswd","scrypt","Buffer","users","_hashPassword","password","_writeFile","getUserData","userData","_verifyPassword","CONSOLE","ConsoleEvent","HANDLE_TYPES","attachedCount","NodeMonkey","rec","inst","bunyanStream","bufferSize","disableLocalOutput","showCallerInfo","convertStyles","ssh","DEFAULT_PORT","os","dataDir","_createLocal","_createRemote","_setupCmdMan","_setupUserManager","_setupServer","_setupSSH","attachConsole","localFn","fn","remoteFn","callerStackDistance","index","proto","local","log","_displayServerWelcome","_cmdMan","addCmd","runCmd","userMan","hideInput","done","user","serverApp","restify","cors","corsMiddleware","origins","allowHeaders","exposeHeaders","credentials","directory","default","setupServer","remoteClients","setupSocket","_sendMessages","clientSettings","sshOpts","keyRe","file","keys","SSHMan","functionName","frame","methodName","fileName","lineNumber","columnNumber","caller","twoBack","sixBack","test","line","column","info","msgBuffer","push","callerInfo","_getCallerInfo","length","shift","cycle","remote","stackdist","handlersActive","serverOptions","handler","_attached"],"mappings":"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","file":"server.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NodeMonkey\"] = factory();\n\telse\n\t\troot[\"NodeMonkey\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 24);\n","module.exports = require(\"@babel/runtime/regenerator\");","/*\n    cycle.js\n    2016-05-01\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint eval, for */\n\n/*property\n    $ref, decycle, forEach, isArray, keys, length, push, retrocycle, stringify,\n    test\n*/\n\nlet origJSON = global.JSON,\n  JSON = {}\nexport default JSON\n\nif (typeof JSON.decycle !== \"function\") {\n  JSON.decycle = function decycle(object, replacer) {\n    \"use strict\"\n\n    // Make a deep copy of an object or array, assuring that there is at most\n    // one instance of each object or array in the resulting structure. The\n    // duplicate references (which might be forming cycles) are replaced with\n    // an object of the form\n\n    //      {\"$ref\": PATH}\n\n    // where the PATH is a JSONPath string that locates the first occurance.\n\n    // So,\n\n    //      var a = [];\n    //      a[0] = a;\n    //      return JSON.stringify(JSON.decycle(a));\n\n    // produces the string '[{\"$ref\":\"$\"}]'.\n\n    // If a replacer function is provided, then it will be called for each value.\n    // A replacer function receives a value and returns a replacement value.\n\n    // JSONPath is used to locate the unique object. $ indicates the top level of\n    // the object or array. [NUMBER] or [STRING] indicates a child element or\n    // property.\n\n    var objects = [] // Keep a reference to each unique object or array\n    var paths = [] // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n      // The derez function recurses through the object, producing the deep copy.\n\n      var i // The loop counter\n      var nu // The new object or array\n\n      // If a replacer function was provided, then call it to get a replacement value.\n\n      if (replacer !== undefined) {\n        value = replacer(value)\n      }\n\n      // typeof null === \"object\", so go on if this value is really an object but not\n      // one of the weird builtin objects.\n\n      if (\n        typeof value === \"object\" &&\n        value !== null &&\n        !(value instanceof Boolean) &&\n        !(value instanceof Date) &&\n        !(value instanceof Number) &&\n        !(value instanceof RegExp) &&\n        !(value instanceof String)\n      ) {\n        // If the value is an object or array, look to see if we have already\n        // encountered it. If so, return a {\"$ref\":PATH} object. This is a hard\n        // linear search that will get slower as the number of unique objects grows.\n        // Someday, this should be replaced with an ES6 WeakMap.\n\n        i = objects.indexOf(value)\n        if (i >= 0) {\n          return { $ref: paths[i] }\n        }\n\n        // Otherwise, accumulate the unique value and its path.\n\n        objects.push(value)\n        paths.push(path)\n\n        // If it is an array, replicate the array.\n\n        if (Array.isArray(value)) {\n          nu = []\n          value.forEach(function (element, i) {\n            nu[i] = derez(element, path + \"[\" + i + \"]\")\n          })\n        } else {\n          // If it is an object, replicate the object.\n\n          nu = {}\n          Object.keys(value).forEach(function (name) {\n            nu[name] = derez(value[name], path + \"[\" + JSON.stringify(name) + \"]\")\n          })\n        }\n        return nu\n      }\n      return value\n    })(object, \"$\")\n  }\n}\n\nif (typeof JSON.retrocycle !== \"function\") {\n  JSON.retrocycle = function retrocycle($) {\n    \"use strict\"\n\n    // Restore an object that was reduced by decycle. Members whose values are\n    // objects of the form\n    //      {$ref: PATH}\n    // are replaced with references to the value found by the PATH. This will\n    // restore cycles. The object will be mutated.\n\n    // The eval function is used to locate the values described by a PATH. The\n    // root object is kept in a $ variable. A regular expression is used to\n    // assure that the PATH is extremely well formed. The regexp contains nested\n    // * quantifiers. That has been known to have extremely bad performance\n    // problems on some browsers for very long strings. A PATH is expected to be\n    // reasonably short. A PATH is allowed to belong to a very restricted subset of\n    // Goessner's JSONPath.\n\n    // So,\n    //      var s = '[{\"$ref\":\"$\"}]';\n    //      return JSON.retrocycle(JSON.parse(s));\n    // produces an array containing a single element which is the array itself.\n\n    var px = /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/\n\n    ;(function rez(value) {\n      // The rez function walks recursively through the object looking for $ref\n      // properties. When it finds one that has a value that is a path, then it\n      // replaces the $ref object with a reference to the value that is found by\n      // the path.\n\n      if (value && typeof value === \"object\") {\n        if (Array.isArray(value)) {\n          value.forEach(function (element, i) {\n            if (typeof element === \"object\" && element !== null) {\n              var path = element.$ref\n              if (typeof path === \"string\" && px.test(path)) {\n                value[i] = eval(path)\n              } else {\n                rez(element)\n              }\n            }\n          })\n        } else {\n          Object.keys(value).forEach(function (name) {\n            var item = value[name]\n            if (typeof item === \"object\" && item !== null) {\n              var path = item.$ref\n              if (typeof path === \"string\" && px.test(path)) {\n                value[name] = eval(path)\n              } else {\n                rez(item)\n              }\n            }\n          })\n        }\n      }\n    })($)\n    return $\n  }\n}\n\nJSON = origJSON\n","module.exports = require(\"source-map-support\");","import os from \"os\"\nimport fs from \"fs\"\nimport path from \"path\"\nimport { EventEmitter } from \"events\"\nimport { execSync } from \"child_process\"\nimport _ from \"lodash\"\nimport keypair from \"keypair\"\nimport cycle from \"../lib/cycle\"\nimport bunyanStream from \"./bunyan-stream\"\nimport setupServer from \"./setup-server\"\nimport setupSocket from \"./setup-socket\"\nimport SSHMan from \"./ssh-manager\"\nimport CmdMan from \"./command-manager\"\nimport UserManager from \"./user-manager\"\nimport utils from \"./utils\"\n\nconst NODE_ENV = process.env.NODE_ENV\nconst DEFAULT_PORT = 50500\nconst CONSOLE = _.mapValues(console)\nconst ConsoleEvent = new EventEmitter()\nconst HANDLE_TYPES = [\"log\", \"info\", \"warn\", \"error\", \"dir\"]\n\nlet attachedCount = 0\n\nclass NodeMonkey {\n  msgBuffer = []\n  BUNYAN_STREAM = bunyanStream(this)\n  _attached = false\n  _typeHandlers = {}\n\n  constructor(opts) {\n    const options = (this.options = _.merge(\n      {\n        server: {\n          // You can provide your own server and Node Monkey will use it instead of creating its own.\n          // However, this MUST be the underlying http server instance, not the express/restify/whatever app.\n          server: null,\n\n          host: \"0.0.0.0\",\n          port: DEFAULT_PORT,\n          silent: false,\n          bufferSize: 50,\n          attachOnStart: true,\n\n          // Only takes effect when Node Monkey is attached to the console\n          disableLocalOutput: false,\n        },\n        client: {\n          showCallerInfo: NODE_ENV === \"production\" ? false : true,\n          convertStyles: true,\n        },\n        ssh: {\n          enabled: false,\n          host: \"0.0.0.0\",\n          port: DEFAULT_PORT + 1,\n          title: `Node Monkey on ${os.hostname()}`,\n          prompt: `[Node Monkey] {@username}@${os.hostname()}:`,\n        },\n\n        // Needed for storing things like user files and SSH host keys\n        dataDir: null,\n      },\n      opts,\n    ))\n\n    this._createLocal()\n    this._createRemote()\n    this._setupCmdMan()\n    this._setupUserManager()\n    this._setupServer()\n    this._setupSSH()\n\n    if (options.server.attachOnStart) {\n      this.attachConsole()\n    }\n\n    // TODO: Deprecated. Remove everything after this line by v1.0.0\n    console.local = _.mapValues(this.local, (fn, method) => {\n      const localFn = (...args) => {\n        return fn(...args)\n      }\n      Object.defineProperty(localFn, \"name\", { value: method })\n      return localFn\n    })\n    console.remote = _.mapValues(this.remote, (fn, method) => {\n      const remoteFn = (...args) => {\n        return fn({ callerStackDistance: 2 }, ...args)\n      }\n      Object.defineProperty(remoteFn, \"name\", { value: method })\n      return remoteFn\n    })\n  }\n\n  _getServerProtocol(server) {\n    if (server._events && server._events.tlsClientError) {\n      return \"https\"\n    }\n    return \"http\"\n  }\n\n  getServerPaths() {\n    const basePath = path.normalize(`${__dirname}/../dist`)\n\n    return {\n      basePath,\n      client: \"monkey.js\",\n      index: \"index.html\",\n    }\n  }\n\n  _displayServerWelcome() {\n    if (!this.options.server.silent) {\n      const server = this.options.server.server\n      if (server.listening) {\n        const proto = this._getServerProtocol(server)\n        const { address, port } = server.address()\n        this.local.log(`Node Monkey listening at ${proto}://${address}:${port}`)\n      } else {\n        server.on(\"listening\", this._displayServerWelcome.bind(this))\n      }\n    }\n  }\n\n  _setupCmdMan() {\n    this._cmdMan = new CmdMan({\n      write: (val, opts) => {\n        console.log(val)\n      },\n      writeLn: (val, opts) => {\n        console.log(val)\n      },\n      error: (val, opts) => {\n        console.error(val)\n      },\n      prompt: (promptTxt, opts, cb) => {\n        if (typeof opts === \"function\") {\n          cb = opts\n          opts = undefined\n        }\n        opts || (opts = {})\n\n        console.warn(\"Prompt not implemented\")\n      },\n    })\n\n    this.addCmd = this._cmdMan.addCmd\n    this.runCmd = this._cmdMan.runCmd\n  }\n\n  _setupUserManager() {\n    const dataDir = this.options.dataDir\n    const userMan = (this.userManager = new UserManager({\n      userFile: dataDir ? `${dataDir}/users.json` : undefined,\n      silent: this.options.server.silent,\n    }))\n\n    this.addCmd(\"showusers\", async (opts, term) => {\n      const users = await userMan.getUsers()\n      term.writeLn(Object.keys(users).join(\"\\n\"))\n    })\n\n    this.addCmd(\"adduser\", (opts, term, done) => {\n      const args = opts.args\n      const username = args._[0]\n\n      if (!username) {\n        term.error(`You must specify a username`)\n        return done()\n      }\n\n      term.prompt(\"Password: \", { hideInput: true }, (error, password) => {\n        term.writeLn()\n        term.prompt(\"Again: \", { hideInput: true }, (error, passwordAgain) => {\n          term.writeLn()\n          if (password === passwordAgain) {\n            userMan\n              .createUser(username, password)\n              .then(() => term.write(`Created user '${username}'`))\n              .catch(term.error)\n              .then(done)\n          } else {\n            term.error(\"Passwords do not match\")\n            done()\n          }\n        })\n      })\n    })\n\n    this.addCmd(\"deluser\", (opts, term, done) => {\n      const args = opts.args\n      const username = args._[0]\n\n      if (!username) {\n        term.error(`You must specify a username`)\n        return done()\n      }\n\n      userMan\n        .deleteUser(username)\n        .then(() => term.write(`Deleted user '${username}'`))\n        .catch(term.error)\n        .then(done)\n    })\n\n    this.addCmd(\"passwd\", (opts, term, done) => {\n      const args = opts.args\n      const user = opts.username\n\n      term.prompt(\"Current password: \", { hideInput: true }, (error, curpwd) => {\n        term.writeLn()\n        userMan.verifyUser(user, curpwd).then((matches) => {\n          if (matches) {\n            term.prompt(\"Password: \", { hideInput: true }, (error, password) => {\n              term.writeLn()\n              term.prompt(\"Again: \", { hideInput: true }, (error, passwordAgain) => {\n                term.writeLn()\n                if (password === passwordAgain) {\n                  userMan\n                    .setPassword(user, password)\n                    .then(() => term.write(`Updated password for ${user}`))\n                    .catch(term.error)\n                    .then(done)\n                } else {\n                  term.error(\"Passwords do not match\")\n                  done()\n                }\n              })\n            })\n          } else {\n            term.error(\"Incorrect password\")\n            done()\n          }\n        })\n      })\n    })\n  }\n\n  _setupServer() {\n    const options = this.options\n    let server = options.server.server\n\n    if (!server) {\n      const serverApp = setupServer({\n        name: \"Node Monkey\",\n      })\n      server = this.options.server.server = serverApp.server\n\n      let { host, port } = options.server\n      serverApp.listen(port, host)\n    }\n\n    this._displayServerWelcome()\n    this.serverApp = server\n    this.remoteClients = setupSocket({\n      server: server.server || server,\n      cmdManager: this._cmdMan,\n      userManager: this.userManager,\n      onAuth: this._sendMessages.bind(this),\n      clientSettings: options.client,\n    })\n  }\n\n  _setupSSH() {\n    const sshOpts = this.options.ssh\n    if (sshOpts.enabled) {\n      const dataDir = this.options.dataDir\n      if (!dataDir) {\n        throw new Error(`Options 'dataDir' is required to enable SSH`)\n      }\n\n      // Get host keys\n      const files = fs.readdirSync(dataDir)\n      const keyRe = /\\.key$/\n      let hostKeys = []\n      for (let file of files) {\n        if (keyRe.test(file)) {\n          hostKeys.push(`${dataDir}/${file}`)\n        }\n      }\n\n      if (!hostKeys.length) {\n        console.log(\"No SSH host key found. Generating new host key...\")\n        let keys = keypair()\n        fs.writeFileSync(`${dataDir}/rsa.key`, keys.private)\n        fs.writeFileSync(`${dataDir}/rsa.key.pub`, keys.public)\n        hostKeys = [`${dataDir}/rsa.key`]\n      }\n\n      this.SSHMan = new SSHMan({\n        monkey: this,\n        cmdManager: this._cmdMan,\n        userManager: this.userManager,\n        silent: this.options.server.silent,\n        host: sshOpts.host,\n        port: sshOpts.port,\n        title: _.result(sshOpts, \"title\"),\n        prompt: _.result(sshOpts, \"prompt\"),\n        hostKeys,\n      })\n    }\n  }\n\n  // TODO: This whole process of trying to identify the true source of the call is so fucking messy and fragile. Need to think\n  //       of a better way to identify the call source and rewrite all this shitty code handling it right now.\n  _getCallerInfo(callerStackDistance) {\n    if (this.options.client.showCallerInfo) {\n      const stack = utils.getStack().map((frame) => {\n        return {\n          functionName: frame.getFunctionName(),\n          methodName: frame.getMethodName(),\n          fileName: frame.getFileName(),\n          lineNumber: frame.getLineNumber(),\n          columnNumber: frame.getColumnNumber(),\n        }\n      })\n\n      let caller = stack.find((frame, index, stack) => {\n        // We're either looking for a console method call or a bunyan log call. This logic will break down if method names change.\n        const twoBack = stack[index - 2]\n        const sixBack = stack[index - 4]\n        if (twoBack && twoBack.functionName === \"Logger._emit\" && /\\/bunyan\\.js$/.test(twoBack.fileName)) {\n          return true\n        } else if (twoBack && sixBack && twoBack.methodName === \"emit\" && sixBack.methodName === \"_sendMessage\") {\n          return true\n        }\n      })\n\n      if (!caller && typeof callerStackDistance === \"number\") {\n        caller = stack[callerStackDistance]\n      }\n\n      if (caller) {\n        return {\n          caller: caller.functionName || caller.methodName,\n          file: caller.fileName,\n          line: caller.lineNumber,\n          column: caller.columnNumber,\n        }\n      }\n    }\n  }\n\n  _sendMessage(info, callerStackDistance) {\n    this.msgBuffer.push({\n      method: info.method,\n      args: info.args,\n      callerInfo: info.callerInfo || this._getCallerInfo(callerStackDistance + 1),\n    })\n    if (this.msgBuffer.length > this.options.server.bufferSize) {\n      this.msgBuffer.shift()\n    }\n    this._sendMessages()\n  }\n\n  _sendMessages() {\n    const remoteClients = this.remoteClients\n    if (_.size(remoteClients.adapter.rooms[\"authed\"])) {\n      _.each(this.msgBuffer, (info) => {\n        remoteClients.to(\"authed\").emit(\"console\", cycle.decycle(info))\n      })\n\n      this.msgBuffer = []\n    }\n  }\n\n  _createLocal() {\n    // NOTE: The console functions here should not be wrapped since these values are used to restore the defaults\n    //       when `detachConsole()` is called.\n    this.local = CONSOLE\n  }\n\n  _createRemote() {\n    let remote = (this.remote = {})\n    HANDLE_TYPES.forEach((method) => {\n      this.remote[method] = (...args) => {\n        const stackdist = args[0] && args[0].callerStackDistance\n        this._sendMessage(\n          {\n            method,\n            args: stackdist ? args.slice(1) : args,\n          },\n          stackdist ? stackdist + 1 : 2,\n        )\n      }\n      Object.defineProperty(remote[method], \"name\", { value: method })\n    })\n  }\n\n  attachConsole(disableLocalOutput) {\n    if (this._attached) {\n      return\n    }\n\n    if (!attachedCount) {\n      // If this function is in the process of handling the log call we will try and prevent potential infinite recursion\n      let handlersActive = 0\n      HANDLE_TYPES.forEach((method) => {\n        console[method] = (...args) => {\n          if (handlersActive) {\n            return this.local[method](...args)\n          }\n\n          ++handlersActive\n          ConsoleEvent.emit(method, ...args)\n          --handlersActive\n        }\n        Object.defineProperty(console[method], \"name\", { value: method })\n      })\n    }\n\n    ++attachedCount\n\n    let serverOptions = this.options.server\n    disableLocalOutput = disableLocalOutput !== undefined ? disableLocalOutput : serverOptions.disableLocalOutput\n\n    _.each(this.remote, (fn, method) => {\n      const handler = (this._typeHandlers[method] = (...args) => {\n        fn({ callerStackDistance: 4 }, ...args)\n\n        if (!disableLocalOutput) {\n          this.local[method](...args)\n        }\n      })\n      Object.defineProperty(handler, \"name\", { value: method })\n\n      ConsoleEvent.on(method, handler)\n    })\n\n    this._attached = true\n  }\n\n  detachConsole() {\n    Object.assign(console, this.local)\n    this._attached = false\n    --attachedCount\n\n    HANDLE_TYPES.forEach((method) => {\n      ConsoleEvent.removeListener(method, this._typeHandlers[method])\n      delete this._typeHandlers[method]\n    })\n  }\n}\n\nconst instances = {}\nlet lastPort = DEFAULT_PORT - 1\nexport default function createInst(options, name = \"default\") {\n  if (typeof options === \"string\") {\n    name = options\n    options = undefined\n  }\n\n  if (!instances[name]) {\n    options || (options = {})\n    let port = _.get(options, \"server.port\")\n    if (port) {\n      lastPort = +port\n    } else {\n      _.set(options, \"server.port\", ++lastPort)\n      _.set(options, \"ssh.port\", ++lastPort)\n    }\n    instances[name] = new NodeMonkey(options)\n  }\n\n  return instances[name]\n}\n\n// Just exporting in case someone needs to wrap this or access the internals for some reason\nexport { NodeMonkey }\n","import commonUtils from \"../lib/common-utils\"\nimport sourceMapSupport from \"source-map-support\"\n\nexport default Object.assign(\n  {\n    parseCommand(str) {\n      const reg = /\"(.*?)\"|'(.*?)'|`(.*?)`|([^\\s\"]+)/gi\n      const arr = []\n      let match\n\n      do {\n        match = reg.exec(str)\n        if (match !== null) {\n          arr.push(match[1] || match[2] || match[3] || match[4])\n        }\n      } while (match !== null)\n\n      return arr\n    },\n\n    getStack() {\n      let prep = Error.prepareStackTrace\n      let limit = Error.stackTraceLimit\n      Error.prepareStackTrace = (error, trace) => trace.map(sourceMapSupport.wrapCallSite)\n      Error.stackTraceLimit = 30\n\n      let stack = new Error().stack\n      Error.prepareStackTrace = prep\n      Error.stackTraceLimit = limit\n\n      return stack.slice(1)\n    },\n\n    getPromiseObj() {\n      const pobj = {}\n      pobj.promise = new Promise((resolve, reject) => {\n        Object.assign(pobj, {\n          resolve,\n          reject,\n        })\n      })\n      return pobj\n    },\n  },\n  commonUtils,\n)\n","export default {\n  isObject(value) {\n    let type = typeof value\n    return !!value && (type == \"object\" || type == \"function\")\n  },\n\n  invert(obj) {\n    let inverted = {}\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        inverted[obj[k]] = k\n      }\n    }\n\n    return inverted\n  },\n}\n","import utils from \"./utils\"\n\nconst BUNYAN_TRACE = 10\nconst BUNYAN_DEBUG = 20\nconst BUNYAN_INFO = 30\nconst BUNYAN_WARN = 40\nconst BUNYAN_ERROR = 50\nconst BUNYAN_FATAL = 60\n\nlet levelFromName = {\n  trace: BUNYAN_TRACE,\n  debug: BUNYAN_DEBUG,\n  info: BUNYAN_INFO,\n  warn: BUNYAN_WARN,\n  error: BUNYAN_ERROR,\n  fatal: BUNYAN_FATAL,\n}\nlet nameFromLevel = utils.invert(levelFromName)\n\nexport default (inst) => {\n  return {\n    write: function (rec) {\n      rec = JSON.parse(rec)\n      inst._sendMessage({\n        method: nameFromLevel[rec.level] || \"info\",\n        args: [rec.msg, rec],\n      })\n    },\n  }\n}\n","import _ from \"lodash\"\nimport utils from \"./utils\"\nimport minimist from \"minimist\"\n\nclass CommandManager {\n  io\n  commands = {}\n\n  constructor(ioInterface) {\n    this.io = ioInterface\n  }\n\n  addCmd = (cmdName, opts, exec) => {\n    if (this.commands[cmdName]) {\n      throw new Error(`'${cmdName}' is already registered as a command`)\n    }\n\n    if (typeof opts === \"function\") {\n      exec = opts\n      opts = {}\n    }\n\n    this.commands[cmdName] = {\n      opts,\n      exec,\n    }\n  }\n\n  // bindI(ioInterface) {\n  //   let boundI = _.mapValues(this)\n  //   Object.assign(\n  //     boundI,\n  //     _.mapValues(this.constructor.prototype, (val, key) => {\n  //       if (val instanceof Function) {\n  //         if (key === \"runCmd\") {\n  //           return val.bind(this, ioInterface)\n  //         }\n  //         return val.bind(this)\n  //       } else {\n  //         return val\n  //       }\n  //     }),\n  //   )\n\n  //   return boundI\n  // }\n\n  runCmd = async (rawCommand, asUser) => {\n    const parsed = utils.parseCommand(rawCommand)\n    const cmdName = parsed[0]\n    const cmd = this.commands[cmdName]\n    const { io } = this\n\n    if (!asUser) {\n      throw new Error(`Missing user context for command '${cmdName}'`)\n    }\n\n    if (!cmd) {\n      throw new Error(`Command not found: '${cmdName}'`)\n    }\n\n    const args = minimist(parsed.slice(1))\n    const doneP = utils.getPromiseObj()\n    const result = cmd.exec(\n      {\n        args,\n        username: asUser,\n      },\n      {\n        write: io.write,\n        writeLn: io.writeLn,\n        error: io.error,\n        prompt: io.prompt,\n      },\n      doneP.resolve,\n    )\n\n    return result.then ? result : doneP.promise\n  }\n}\n\nexport default CommandManager\n","import _ from \"lodash\"\nimport socketio from \"socket.io\"\nimport CmdMan from \"./command-manager\"\n\nexport default (options) => {\n  let io, ns\n  let userManager = options.userManager\n\n  if (typeof options.server === \"function\") {\n    io = socketio(options.server)\n  } else {\n    io = socketio()\n    io.attach(options.server)\n  }\n\n  ns = io.of(\"/nm\")\n  ns.on(\"connection\", (socket) => {\n    let cmdMan = null\n    socket.emit(\"settings\", options.clientSettings)\n    socket.emit(\"auth\")\n\n    socket.on(\"auth\", (creds) => {\n      userManager\n        .verifyUser(creds.username, creds.password)\n        .then((result) => {\n          socket.emit(\"authResponse\", result, result ? undefined : \"Incorrect password\")\n          if (result) {\n            socket.username = creds.username\n            socket.join(\"authed\")\n            if (options.onAuth) {\n              options.onAuth(socket)\n            }\n          }\n        })\n        .catch((err) => {\n          socket.emit(\"authResponse\", false, err)\n        })\n    })\n\n    socket.on(\"cmd\", (cmdId, command) => {\n      if (!socket.username) {\n        socket.emit(\"cmdResponse\", cmdId, `You are not authorized to run commands`)\n        return\n      }\n\n      if (!cmdMan) {\n        cmdMan = createCmdMan(options.cmdManager, socket)\n      }\n\n      cmdMan\n        .runCmd(command, socket.username)\n        .then((output) => {\n          socket.emit(\"cmdResponse\", cmdId, null, output)\n        })\n        .catch((err) => {\n          socket.emit(\"cmdResponse\", cmdId, (err && err.message) || err, null)\n        })\n    })\n  })\n\n  _.each(options.handlers, function (handler, event) {\n    io.on(event, handler)\n  })\n\n  return ns\n}\n\nfunction createCmdMan(cmdManager, socket) {\n  let promptId = 0,\n    prompts = {}\n\n  let cmdManOpts = {\n    writeLn: null,\n    write: (val, opts) => {\n      if (!val) return\n\n      socket.emit(\"console\", {\n        method: \"log\",\n        args: [val],\n      })\n    },\n    error: (val, opts) => {\n      if (!val) return\n\n      socket.emit(\"console\", {\n        method: \"error\",\n        args: [val],\n      })\n    },\n    prompt: (promptTxt, opts, cb) => {\n      if (typeof opts === \"function\") {\n        cb = opts\n        opts = undefined\n      }\n      opts || (opts = {})\n\n      let pid = promptId++\n      socket.emit(\"prompt\", pid, promptTxt, opts)\n\n      prompts[pid] = cb\n    },\n  }\n  cmdManOpts.writeLn = cmdManOpts.write\n\n  socket.on(\"promptResponse\", (promptId, response) => {\n    if (prompts[promptId]) {\n      prompts[promptId](null, response)\n    }\n  })\n\n  return cmdManager.bindI(cmdManOpts)\n}\n","import fs from \"fs\"\nimport tty from \"tty\"\nimport pty from \"node-pty\"\nimport ssh2 from \"ssh2\"\nimport termkit from \"terminal-kit\"\n\nclass SSHManager {\n  options = {\n    host: \"127.0.0.1\",\n    port: 50501,\n    title: \"Node Monkey\",\n    prompt: \"Node Monkey:\",\n    silent: false,\n  }\n  server\n  clients = new Set()\n\n  constructor(options) {\n    options = Object.assign(this.options, options)\n\n    this.server = new ssh2.Server(\n      {\n        hostKeys: options.hostKeys.map((file) => {\n          return fs.readFileSync(file)\n        }),\n      },\n      this.onClient.bind(this),\n    )\n\n    const monkey = this.options.monkey\n    this.server.listen(options.port, options.host, function () {\n      options.silent || monkey.local.log(`SSH listening on ${this.address().port}`)\n    })\n  }\n\n  shutdown() {\n    const clients = this.clients\n    for (const c of clients) {\n      c.write(\"\\nShutting down\")\n      c.close()\n    }\n  }\n\n  onClient(client) {\n    const { cmdManager, userManager, title, prompt } = this.options\n\n    this.clients.add(\n      new SSHClient({\n        client,\n        cmdManager,\n        userManager,\n        title,\n        prompt,\n        onClose: () => this.clients.delete(client),\n      }),\n    )\n  }\n}\n\nclass SSHClient {\n  constructor(options) {\n    this.options = options\n    this.client = options.client\n    this.cmdMan = null\n    this.userManager = options.userManager\n    this.session = null\n    this.stream = null\n    this.pty = null\n    this.term = null\n    this.ptyInfo = null\n\n    this.title = options.title\n    this.promptTxt = `${options.prompt} `\n    this.inputActive = false\n    this.cmdHistory = []\n\n    this.username = null\n\n    this.client.on(\"authentication\", this.onAuth.bind(this))\n    this.client.on(\"ready\", this.onReady.bind(this))\n    this.client.on(\"end\", this.onClose.bind(this))\n  }\n\n  _initCmdMan() {\n    let cmdManOpts = {\n      writeLn: null,\n      write: (val, opts) => {\n        opts || (opts = {})\n        val || (val = \"\")\n\n        if (opts.bold) {\n          this.term.bold(val)\n        } else {\n          this.term(val)\n        }\n\n        if (opts.newline) {\n          this.term.nextLine()\n        }\n      },\n      error: (val, opts) => {\n        opts || (opts = {})\n\n        // TODO: Apparently by sending this to stdout there is a timing issue and anything sent to\n        //       stdout appears before this value is sent to stderr for some reason.\n        // this.term.red.error(val)\n        this.term.red(val)\n\n        if (opts.newline) {\n          this.term.nextLine()\n        }\n      },\n      prompt: (promptTxt = \"\", opts, cb) => {\n        if (typeof opts === \"function\") {\n          cb = opts\n          opts = undefined\n        }\n        opts || (opts = {})\n\n        let inputOpts = {}\n        if (opts.hideInput) {\n          inputOpts.echo = false\n        }\n\n        this.term(promptTxt)\n        this.term.inputField(inputOpts, cb)\n      },\n    }\n    cmdManOpts.writeLn = (val, opts) => {\n      opts || (opts = {})\n      opts.newline = true\n      cmdManOpts.write(val, opts)\n    }\n    this.cmdMan = this.options.cmdManager.bindI(cmdManOpts)\n  }\n\n  write(msg, { style = undefined }) {\n    if (this.term) {\n      if (style) {\n        this.term[style](msg)\n      } else {\n        this.term(msg)\n      }\n    }\n  }\n\n  close() {\n    if (this.stream) {\n      this.stream.end()\n    }\n    this.onClose()\n  }\n\n  onAuth(ctx) {\n    if (ctx.method == \"password\") {\n      this.userManager\n        .verifyUser(ctx.username, ctx.password)\n        .then((result) => {\n          if (result) {\n            this.username = ctx.username\n            ctx.accept()\n          } else {\n            ctx.reject()\n          }\n        })\n        .catch((err) => {\n          ctx.reject()\n        })\n    } else if (ctx.method == \"publickey\") {\n      ctx.reject()\n    } else {\n      ctx.reject()\n    }\n  }\n\n  onReady() {\n    this.client.on(\"session\", (accept, reject) => {\n      this.session = accept()\n\n      this.session\n        .once(\"pty\", (accept, reject, info) => {\n          this.ptyInfo = info\n          accept && accept()\n        })\n        .on(\"window-change\", (accept, reject, info) => {\n          Object.assign(this.ptyInfo, info)\n          this._resize()\n          accept && accept()\n        })\n        .once(\"shell\", (accept, reject) => {\n          this.stream = accept()\n          this._initCmdMan()\n          this._initStream()\n          this._initPty()\n          this._initTerm()\n        })\n    })\n  }\n\n  onClose() {\n    let onClose = this.options.onClose\n    onClose && onClose()\n  }\n\n  onKey(name, matches, data) {\n    if (name === \"CTRL_L\") {\n      this.clearScreen()\n    } else if (name === \"CTRL_C\") {\n      this.inputActive = false\n      this.inputField.abort()\n      this.term(\"\\n^^C\\n\")\n      this.prompt()\n    } else if (name === \"CTRL_D\") {\n      let input = this.inputField.getInput()\n      if (!input.length) {\n        this.term.nextLine()\n        setTimeout(() => {\n          this.close()\n        }, 0)\n      }\n    }\n  }\n\n  _resize({ term } = this) {\n    if (term) {\n      term.stdout.emit(\"resize\")\n    }\n  }\n\n  _initStream() {\n    const stream = this.stream\n    stream.name = this.title\n    stream.isTTY = true\n    stream.setRawMode = () => {}\n    stream.on(\"error\", (error) => {\n      console.error(\"SSH stream error:\", error.message)\n    })\n  }\n\n  _initPty() {\n    const newPty = pty.native.open(this.ptyInfo.cols, this.ptyInfo.rows)\n    this.pty = {\n      master_fd: newPty.master,\n      slave_fd: newPty.slave,\n      master: new tty.WriteStream(newPty.master),\n      slave: new tty.ReadStream(newPty.slave),\n    }\n    this.pty.slave.getWindowSize = () => {\n      return [this.ptyInfo.cols, this.ptyInfo.rows]\n    }\n    this.stream.stdin.pipe(this.pty.master)\n    this.pty.master.pipe(this.stream.stdout)\n  }\n\n  _initTerm() {\n    const term = (this.term = termkit.createTerminal({\n      stdin: this.pty.slave,\n      stdout: this.pty.slave,\n      stderr: this.pty.slave,\n      generic: this.ptyInfo.term,\n      appName: this.title,\n    }))\n\n    term.on(\"key\", this.onKey.bind(this))\n    term.windowTitle(this._interpolate(this.title))\n    this.clearScreen()\n  }\n\n  _interpolate(str) {\n    let varRe = /{@(.+?)}/g\n    let vars = {\n      username: this.username,\n    }\n\n    let match\n    while ((match = varRe.exec(str))) {\n      if (vars[match[1]]) {\n        str = str.replace(match[0], vars[match[1]])\n      }\n    }\n\n    return str\n  }\n\n  clearScreen() {\n    this.term.clear()\n    this.prompt()\n  }\n\n  prompt() {\n    let term = this.term\n    term.windowTitle(this._interpolate(this.title))\n    term.bold(this._interpolate(this.promptTxt))\n\n    if (!this.inputActive) {\n      this.inputActive = true\n      this.inputField = term.inputField(\n        {\n          history: this.cmdHistory,\n          autoComplete: Object.keys(this.cmdMan.commands),\n          autoCompleteMenu: true,\n        },\n        (error, input) => {\n          this.inputActive = false\n          term.nextLine()\n\n          if (error) {\n            return term.error(error.message || error)\n          }\n\n          if (!input) {\n            return this.prompt()\n          }\n          input[0] !== \" \" && this.cmdHistory.push(input)\n\n          if (input === \"exit\") {\n            // This is delayed briefly so the newline can be echoed to the client, creating cleaner output when exiting\n            setTimeout(this.close.bind(this))\n          } else if (input === \"clear\") {\n            this.clearScreen()\n          } else if (input) {\n            this.cmdMan\n              .runCmd(input, this.username)\n              .then((output) => {\n                if (typeof output !== \"string\") {\n                  output = JSON.stringify(output, null, \"  \")\n                }\n                this.term(output)\n                this.term.nextLine()\n                this.prompt()\n              })\n              .catch((err) => {\n                if (typeof err !== \"string\") {\n                  err = err.message || JSON.stringify(err, null, \"  \")\n                }\n                this.term.red.error(err)\n                this.term.nextLine()\n                this.prompt()\n              })\n          } else {\n            this.prompt()\n          }\n        },\n      )\n    }\n  }\n}\n\nexport default SSHManager\n","import fs from \"fs\"\nimport scrypt from \"scrypt-kdf\"\n\nclass UserManager {\n  userFile\n  userFileCache = null\n  userFileCreated = false\n\n  constructor(options) {\n    this.userFile = options.userFile\n\n    if (!options.silent) {\n      this.getUsers().then((users) => {\n        const usernames = Object.keys(users)\n        if (!usernames.length) {\n          if (process.env.NODE_ENV === \"production\") {\n            console.warn(\n              `No users have been created and you are running in production mode so you will not be able to login.\\n`,\n            )\n          } else {\n            console.warn(\n              `It seems there are no users and you are not running in production mode so you will not be able to login. This is probably a bug. Please report it!\\n`,\n            )\n          }\n        } else if (usernames.length === 1 && usernames[0] === \"guest\") {\n          console.warn(\n            `[WARN] No users detected. You can login with default user 'guest' and password 'guest' when prompted.\\n` +\n              `This user will be disabled when you create a user account.\\n`,\n          )\n        }\n      })\n    }\n  }\n\n  async getUsers() {\n    if (this.userFileCache) {\n      return this.userFileCache\n    }\n\n    try {\n      if (!this.userFile) {\n        let err = new Error(`No user file specified`)\n        err.code = \"ENOENT\"\n        throw err\n      }\n\n      this.userFileCache = JSON.parse(fs.readFileSync(this.userFile).toString(\"base64\"))\n      this.userFileCreated = true\n      setTimeout(() => {\n        this.userFileCache = null\n      }, 5000)\n\n      return this.userFileCache\n    } catch (err) {\n      if (err.code === \"ENOENT\") {\n        return process.env.NODE_ENV === \"production\"\n          ? {}\n          : {\n              guest: {\n                password:\n                  \"c2NyeXB0AA8AAAAIAAAAAc8D4r96lep3aBQSBeAqf0a+9MX6KyB6zKTF9Nk3ruTPIXrzy8IM7vjSLpIKuVZMNTZZ72CMqKp/PQmnyXmf7wGup1bWBGSwoV5ymA72ZzZg\",\n              },\n            }\n      }\n      throw err\n    }\n  }\n\n  _writeFile(data) {\n    this.userFileCache = null\n    fs.writeFileSync(this.userFile, JSON.stringify(data, null, \"  \"))\n    this.userFileCreated = true\n  }\n\n  async _hashPassword(passwd) {\n    return (await scrypt.kdf(passwd, { logN: 15, r: 8, p: 1 })).toString(\"base64\")\n  }\n\n  async _verifyPassword(actualPasswd, testPasswd) {\n    return scrypt.verify(Buffer.from(actualPasswd, \"base64\"), testPasswd)\n  }\n\n  async createUser(username, password) {\n    if (!this.userFile) {\n      throw new Error(`No user file found. Did you forget to set the 'dataDir' option?`)\n    }\n\n    const users = await this.getUsers()\n    if (users[username]) {\n      throw new Error(`User '${username}' already exists`)\n    }\n\n    if (!this.userFileCreated) {\n      delete users[\"guest\"]\n    }\n\n    users[username] = {\n      password: await this._hashPassword(password),\n    }\n    this._writeFile(users)\n  }\n\n  async deleteUser(username) {\n    if (!this.userFile) {\n      throw new Error(`No user file found. Did you forget to set the 'dataDir' option?`)\n    }\n\n    const users = await this.getUsers()\n    if (!users[username]) {\n      throw new Error(`User '${username}' does not exist`)\n    }\n\n    if (!this.userFileCreated) {\n      throw new Error(`User file has not been created`)\n    }\n\n    delete users[username]\n    this._writeFile(users)\n  }\n\n  async setPassword(username, password) {\n    if (!this.userFile) {\n      throw new Error(`No user file found. Did you forget to set the 'dataDir' option?`)\n    }\n\n    const users = await this.getUsers()\n    users[username].password = await this._hashPassword(password)\n    this._writeFile(users)\n  }\n\n  async getUserData(username) {\n    const users = await this.getUsers()\n    if (!users[username]) {\n      throw new Error(`User '${username}' does not exist`)\n    }\n\n    return users[username]\n  }\n\n  async verifyUser(username, passwd) {\n    const userData = await this.getUserData(username)\n    return this._verifyPassword(userData.password, passwd)\n  }\n}\n\nexport default UserManager\n","import restify from \"restify\"\nimport corsMiddleware from \"restify-cors-middleware\"\n\nexport default (options) => {\n  const server = restify.createServer()\n  const cors = corsMiddleware({\n    origins: [/https?:\\/\\/.+/],\n    allowHeaders: [],\n    exposeHeaders: [],\n    credentials: true,\n  })\n\n  server.pre(restify.pre.userAgentConnection())\n  server.pre(cors.preflight)\n  server.use(restify.plugins.gzipResponse())\n  server.use(cors.actual)\n\n  server.get(\n    \"*\",\n    restify.plugins.serveStatic({\n      directory: __dirname,\n      default: \"index.html\",\n    }),\n  )\n\n  return server\n}\n"],"sourceRoot":""}